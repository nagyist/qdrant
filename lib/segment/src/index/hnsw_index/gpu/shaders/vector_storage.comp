#ifndef VECTOR_STORAGE_HEADER
#define VECTOR_STORAGE_HEADER

#ifndef VECTOR_STORAGE_LAYOUT_SET
#error "VECTOR_STORAGE_LAYOUT_SET not defined"
#endif

#include "common.comp"

#ifdef VECTOR_STORAGE_ELEMENT_FLOAT32
#include "vector_storage_f32.comp"
#endif

#ifdef VECTOR_STORAGE_ELEMENT_FLOAT16
#include "vector_storage_f16.comp"
#endif

#ifdef VECTOR_STORAGE_ELEMENT_UINT8
#include "vector_storage_u8.comp"
#endif

#ifdef VECTOR_STORAGE_ELEMENT_PQ
#include "vector_storage_pq.comp"
#endif

#ifdef VECTOR_STORAGE_ELEMENT_SQ
#include "vector_storage_sq.comp"
#endif

#ifdef VECTOR_STORAGE_ELEMENT_BINARY
#include "vector_storage_bq.comp"
#endif

#define STORAGES_COUNT 4
#define STORAGE(STORAGE_INDEX) CONCAT(vectors, STORAGE_INDEX)

#define VECTOR_STORAGE_DEFINE(STORAGE_INDEX) \
    layout(set = VECTOR_STORAGE_LAYOUT_SET, binding = STORAGE_INDEX) \
    readonly buffer CONCAT(Vectors, STORAGE_INDEX) { \
        VECTOR_STORAGE_ELEMENT_TYPE data[]; \
    } STORAGE(STORAGE_INDEX);

VECTOR_STORAGE_DEFINE(0)
VECTOR_STORAGE_DEFINE(1)
VECTOR_STORAGE_DEFINE(2)
VECTOR_STORAGE_DEFINE(3)

// SQ offsets
#ifdef VECTOR_STORAGE_ELEMENT_SQ

layout(set = VECTOR_STORAGE_LAYOUT_SET, binding = STORAGES_COUNT) \
readonly buffer VectorOffsets { \
    float data[]; \
} vector_offsets;

#endif

#if DIM / (4 * SUBGROUP_SIZE) > 1

#define VECTOR_STORAGE_SCORE_SUBGROUP(STORAGE_INDEX) \
    for (uint i = 0; i < DIM / (4 * SUBGROUP_SIZE); i++, index += SUBGROUP_SIZE) { \
        result += VECTOR_STORAGE_SCORE_ELEMENT( \
            STORAGE(STORAGE_INDEX).data[index], \
            target_cache[i] \
        ); \
    }

#define VECTOR_STORAGE_SET_TARGET(STORAGE_INDEX) \
    for (uint i = 0; i < DIM / (4 * SUBGROUP_SIZE); i++, index += SUBGROUP_SIZE) { \
        target_cache[i] = STORAGE(STORAGE_INDEX).data[index]; \
    }

VECTOR_STORAGE_ELEMENT_TYPE target_cache[DIM / (4 * SUBGROUP_SIZE)];

#else

#define VECTOR_STORAGE_SCORE_SUBGROUP(STORAGE_INDEX) \
    result += VECTOR_STORAGE_SCORE_ELEMENT( \
        STORAGE(STORAGE_INDEX).data[index], \
        target_cache \
    );

#define VECTOR_STORAGE_SET_TARGET(STORAGE_INDEX) \
    target_cache = STORAGE(STORAGE_INDEX).data[index];

VECTOR_STORAGE_ELEMENT_TYPE target_cache;

#endif

#ifdef VECTOR_STORAGE_ELEMENT_SQ
float target_offset;
#endif

void set_target(uint point_id) {
    uint index = (point_id / STORAGES_COUNT) * (DIM / 4) + SUBGROUP_INVOCATION_ID;
    uint storage_index = point_id % STORAGES_COUNT;
    switch (storage_index) {
    case 0:
        VECTOR_STORAGE_SET_TARGET(0);
        break;
    case 1:
        VECTOR_STORAGE_SET_TARGET(1);
        break;
    case 2:
        VECTOR_STORAGE_SET_TARGET(2);
        break;
    case 3:
        VECTOR_STORAGE_SET_TARGET(3);
        break;
    }

#ifdef VECTOR_STORAGE_ELEMENT_SQ
    target_offset = vector_offsets.data[point_id];
#endif
}

float similarity(uint point_id) {
    VECTOR_STORAGE_PREPROCESS();

    float result = 0.0;
    uint index = (point_id / STORAGES_COUNT) * (DIM / 4) + SUBGROUP_INVOCATION_ID;
    uint storage_index = point_id % STORAGES_COUNT;
    switch (storage_index) {
    case 0:
        VECTOR_STORAGE_SCORE_SUBGROUP(0);
        break;
    case 1:
        VECTOR_STORAGE_SCORE_SUBGROUP(1);
        break;
    case 2:
        VECTOR_STORAGE_SCORE_SUBGROUP(2);
        break;
    case 3:
        VECTOR_STORAGE_SCORE_SUBGROUP(3);
        break;
    }

    VECTOR_STORAGE_POSTPROCESS_SCORE(result);
    return result;
}

#endif
